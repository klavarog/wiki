Что у нас делает стандартная клавиатура? Считывает нажатия клавиш и отправляет их скан-коды. Нужно ли что-то большее? Нет, не нужно. Максимум сделать клавиатуру физически удобнее и эргономичнее, но статья — про софтовую часть. Что же не так с софтовой частью? Программы, а также само ядро системы совершенно не умеют с этим правильно работать! Я решил полностью описать, как, в моём представлении, программы должны получать сообщения ввода:

# Принципы

*. Никаких «сырых» перехватов клавиш
*. ~~Правда~~ Ввод или действие
*. IME для каждого, а не для азиатов
*. Слои как само собой разумеющееся

# Что есть действие

Действие — это то, что программа будет принимать по умолчанию вместо сочетаний клавиш и клавиш управления. То есть, это все нажатия клавиш сделанные не для ввода текста.

У файлов есть MIME-типы, а у Linux есть иконки которые имеют названия. К чему это я? К тому что мы будем перехватывать не `Ctrl+A` а `select_all`. А при нажатий каких клавиш будет посылаться это действие, уже будет решать сама система ввода.

Стоп, а как же мне тогда сделать, чтобы в моей программе по нажатию на Ctrl+Alt+P вылезал котик? Всё просто, при установке программа тупо регистрирует нужные действия и предлагает для них дефолтный хоткей. Вот пример разных действий:

table {
! Действие ! Деф. хоткей
| vasya-app:show_cat | Ctrl+Alt+P
| vasya-app:map | F5
| game:forward | w
| messenger:send | Ctrl+Enter
| refresh | F5
| copy | Ctrl+C
| left | ←
}

Если так получится, что клавиша будет иметь 2 действия, она будет оправлять их оба. Также для нормальной работы `game:forward` и других подобных действий программе должен будет оправляться сигнал начала и сигнал конца.

Что нам всё это даёт? Это даёт удобство пользователям, потому что они в любой момент могут поменять хоткеи сразу для нескольких программ, в том числе ещё не установленных. Разрабы тоже не остаются в стороне, ибо теперь им не надо писать код для смены хоткеев.

Кстати, зачатки данной технологии есть у KDE, а именно можно поменять все хоткеи из системных настроек, в том числе для нескольких программ сразу.

# Под капотом

Чтобы определить, какое действие должно подаваться, система ввода должна будет прочитать свой конфиг. Данный конфиг должен поддерживать слои и быть очень прост в настройке. Лично я предлагаю сделать какой-то такой главный файл в JSON-формате:

```
{
  "qwerty": ["zxx/main", "eng/qwerty"],
  "QWERTY": ["zxx/main", "eng/QWERTY"],
  "jcuken": ["zxx/main", "rus/jcuken"],
  "JCUKEN": ["zxx/main", "rus/JCUKEN"]
  "ctrl": ["zxx/main", "zxx/ctrl"]
  "super": ["zxx/main", "zxx/super"]
  "alt": ["zxx/main", "zxx/alt"]
}
```

Что это такое? Это описание слоев, в данной расскладке их всего 7. Сами слои состоят из шаблонов, которые поочерёдно накладываются друг на друга. Например шаблон zxx/main описывает где находятся слоефикаторы, а также независимые от языков клавиши, например пробел. zxx/ctrl описывает какие действия у нас происходят по зажатию Ctrl и нажатию клавиши и так далее.

Сами шаблоны хранятся как файлы в папках. Если, к примеру, я хочу поменять Ctrl и Alt местами, я скопирую файл zxx/main себе в домашнюю директорию (из /etc/gkb в ~/.config/gkb) и тупо поменяю в нём местами ctrl и alt. Таким же способом можно делать любые более сложные вещи.

# Ввод текста

Полностью рассказав про работу хоткеев, я совершенно не рассказал, как будет вводиться текст. Вводиться он будет так же не менее сложно. А именно, программа будет запрашивать режим ввода текста.
Во время ввода текста, будут передаваться не действия, а сигналы изменения текста. Сам текст будет состоять из символов, которые будут прописанны в шаблон рядом с действиями. Сами же символы, мало того, что могут быть любыми из unicode и состоять из нескольких символов, так они ещё могут передаваться в программу не на прямую, а через IME. Что это нам даёт? Да кучу всего, начиная автозаменами и заканчивая собственными модулями! К примеру, если я пишу shrug, это автоматически может заменяться на ¯\\_(ツ)_/¯. Более того, сам IME может вполне себе «дружить» с текущей программой, и если я в какой-нибудь GualseIDE буду писать st, мне может быть предложено дополнить текст до struct. Также, в идеале, IME должен поддеживать простое написание дополнений, которые смогут работать в реальном времяни. Пример такого дополнения — по слову «сегодня» предлагать вставить текущюю дату.

# Недоработки

Поразмышляв некоторое время время, я понял какие проблемы ещё не решены:
* Как быть со старыми программами?
* Как быть с виртуальными машинами которые передают клавиши гостевой системе?
* Здесь не хватает аккордов.

# Дополнение

=> https://t.me/gualse_rolling/395 | Небольшое продолжение рассуждений в ТГ