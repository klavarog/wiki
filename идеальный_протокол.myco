Текущий HID-протокол для клавиатур не нравится, поэтому есть нужда придумывать свои клавиатурные протоколы. Описываем свои желания и имплементации (лол) тут.

## Протокол [[u/bouncepaw|Баунса]]
Я описывал, как похожий протокол мог бы работать на основе гемини в своём гемлоге. Прочитать можно [[https://proxy.vulpes.one/gemini/tanelorn.city/~bouncepaw/gemlog/gemini-keeb-protocol.gemini|здесь]], например.

### Носитель
Допустим, этот протокол может передаваться через что угодно. Keyboard over IP, Keyboard over Bluetooth, Keyboard over USB.

### Двухсторонность
Клавиатура и компьютер должны плотно взаимодействовать для достижения эффекта.

В ХИД такого нет. Клавиатура отправляет сканкоды в комп. Что будет дальше — никто не знает. Максимум, что комп скажет клавиатуре — это включит лампочку.

### Разделение ролей
Клавиатура делает три вещи:
*. Отправляет координаты нажатых клавиш
*. Хранит информацию о себе и раскладке
*. Позволяет компьютеру эту информацию читать и частично менять

Компьютер делает всё остальное.

### Устройство
**Профиль** — совокупность раскладок и настроек клавиатуры. У каждой клавиатуры должен быть один стандартный иммутабельный профиль с латиницей и минимум один пользовательский мутабельный профиль с чем угодно.

**Раскладка** — языковая. Русская, английская, что угодно.

Раскладки состоят из **слоёв**.

Каждый слой заполнен **кирунами** (key rune) — примерно то же самое, что и кикоды ймк, но в тысячу раз сильнее. Поддерживаются все символы уникода.

### Печать
Клавиатура ничего не печатает. Она просто говорит, какая у неё раскладка, и какие клавиши надо нажимать. Ввод букв — дело компьютера.

В этом вот ключевое отличие от традиционной клавиатурной парадигмы. Это обеспечивает одинаковую работу клавиатуры на любом компьютере, где есть поддержка этого протокола.

На клавиатуре вообще ничего не происходит. Слоефикатор не включает слой на клавиатуре. Он говорит, что слой должен быть включён. Компьютер знает о слоях. Более того, слои синхронизированы между всеми подключёнными к компу клавиатурами. С модификаторами аналогично (если потребность в такой концепции ещё нужна).

### Настройка
На любом компе должен быть софт, который позволяет наглядно посмотреть, что клавиатура умеет, какие у неё раскладки и профили. Можно быстро добавить какой-нибудь недостающий язык в клавиатуру, например. Можно ещё прикрутить какой-нибудь маркет раскладок.

### Имплементация
Отказ от логики печати со стороны клавиатуры позволяет это накостылять. Какой-нибудь софт говорит с нашей клавиатурой, а потом конвертирует это в обычные ОСные клавиатурные сигналы.

## Протокол [[u/daninspace|Дана]]
Клавиатура посылает символы Юникода. Для функциональных клавиш типа Enter, Shift, Tab, Esc, Ctrl и т.д. зарезервированы отдельные символы. ОС может не иметь встроенных раскладок вообще - она читает готовые символы (ну разве что для совместимости со старыми). Для частых вещей типа  цикличной смены раскладки, жесткой смены раскладки, медиаклавиш (изменение громкости, пауза и т.п.) и вообще для всего, что хочется, можно зарезервировать свой символ в Юникоде - места хватит на всё. Клавиатуру так же легко программировать - по сути просто настраивать отправляемый текст. Хочешь запятую с пробелом - просто пишешь что то вроде ```KEY_1 = ", ";```. Так же очень легко получается программировать слои и т.п. Для языков вроде корейского легко делать автозамену букв на иероглифы  прямо в клавиатуре. Для поддержки протокола не требуется усложнение или удорожание устройства клавиатуры - обычные люди не заметят разницы при переходе на новый протокол.