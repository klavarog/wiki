Текущий HID-протокол для клавиатур не нравится, поэтому есть нужда придумывать свои клавиатурные протоколы. Описываем свои желания и имплементации (лол) тут.

= Общие принципы наших протоколоидей
*. Программируемость клавиатуры как часть протокола
*. Поддержка ввода любых символов

= Протокол [[u/bouncepaw|Баунса]]
Я описывал, как похожий протокол мог бы работать на основе гемини в своём гемлоге. Прочитать можно [[https://proxy.vulpes.one/gemini/tanelorn.city/~bouncepaw/gemlog/gemini-keeb-protocol.gemini|здесь]], например.

== Носитель
Допустим, этот протокол может передаваться через что угодно. Keyboard over IP, Keyboard over Bluetooth, Keyboard over USB.

== Двухсторонность
Клавиатура и компьютер должны плотно взаимодействовать для достижения эффекта.

В ХИД такого нет. Так так: клавиатура отправляет сканкоды в комп. Что будет дальше — никто не знает. Максимум, что комп скажет клавиатуре — это включит лампочку.

**Steve Key:** Не соображу пока, **зачем** клавиатуре принимать какую-либо информацию с компьютера, кроме светодиодов? И то под большим вопросом: CapsLock будет не нужен (всё в клавиатуре!), ScrollLock — кто вообще помнит, что оно делает, NumLock — опять-таки, всё будет в клавиатуре (и, кстати, все помнят, что режим NumPad-а «инвертируются» Shift-ом?)
* **bouncepaw:** Ну как зачем, чтобы записывать настройки и раскладки.
**Steve Key:** Переключение раскладки будет происходить в клавиатуре, из неё же будут выдаваться любые юникод-символы. Алфавит каждый зашьёт в свою клавиатуру сам, нужные ему типографские символы и эмоджи — тоже. Компьютеру об этом знать не нужно, его дело — выводить на экран посылаемые ему юникоды и исполнять служебные символы (команды типа Ctrl+V).
* **bouncepaw:** В клавиатуре не происходит переключение раскладки. В ней //хранятся// все раскладки, есть кнопки переключения раскладки, но переключаются они на компе. А вообще, в чём суть этого комментария? Я не понял, в кого камень летит.
**Steve Key:** Из последней строчки следует, что «для совместимости» по новому протоколу надо будет отправлять и «стандартные» scan-коды клавиш, чтобы программы понимали, что ты нажал не Ctrl+национальную_кракозяблу, а Ctrl+V).
* **bouncepaw:** Ничего такого не следует, последняя строчка целиком посвящена HID, а не моему протоколу. Но вообще, для такого как раз я и придумал иммутабельный профиль с латиницей (см. ниже).

== Разделение ролей
Клавиатура делает три вещи:
*. Отправляет координаты нажатых клавиш
*. Хранит информацию о себе и раскладке
*. Позволяет компьютеру эту информацию читать и частично менять

**Steve Key:** считаю, что компьютеру не́зачем лезть в клавиатуру — это только усложнит протокол и вообще всё устройство. Клавиатура сама вполне справится, если мало AVR-а, то легко перейти на STM.
* **bouncepaw:** если ему незачем лезть туда, то во всём протоколе нет смысла. Вся суть в том, что комп может лезть в клавиатуру.

Компьютер делает всё остальное.

== Устройство
**Профиль** — совокупность раскладок и настроек клавиатуры. У каждой клавиатуры должен быть один стандартный иммутабельный профиль с латиницей и минимум один пользовательский мутабельный профиль с чем угодно.

**Раскладка** — языковая. Русская, английская, что угодно.

Раскладки состоят из **слоёв**.

Каждый слой заполнен **кирунами** (key rune) — примерно то же самое, что и кикоды ймк, но в тысячу раз сильнее. Поддерживаются все символы уникода.

== Печать
Клавиатура ничего не печатает. Она просто говорит, какая у неё раскладка, и какие клавиши надо нажимать. Ввод букв — дело компьютера.

В этом вот ключевое отличие от традиционной клавиатурной парадигмы. Это обеспечивает одинаковую работу клавиатуры на любом компьютере, где есть поддержка этого протокола.

**Steve Key:** вроде бы, именно **сейчас** «клавиатура ничего не печатает»? Она «просто» выдаёт компьютеру скан-коды клавиш, а уже компьютер делает всё остальное. Непонятно, что мы хотим изменить и чем это будет лучше…
* **bouncepaw:** в принципе да, клавиатуры вообще ничего не делают, это компьютер решает, что будет. А то, что ты не понял, что я придумал, я понял :-) Потом подробнее+понятнее напишу, конечно.

На клавиатуре вообще ничего не происходит. Слоефикатор не включает слой на клавиатуре. Он говорит, что слой должен быть включён. Компьютер знает о слоях. Более того, слои синхронизированы между всеми подключёнными к компу клавиатурами. С модификаторами аналогично (если потребность в такой концепции ещё нужна).

== Настройка
На любом компе должен быть софт, который позволяет наглядно посмотреть, что клавиатура умеет, какие у неё раскладки и профили. Можно быстро добавить какой-нибудь недостающий язык в клавиатуру, например. Можно ещё прикрутить какой-нибудь маркет раскладок.

== Имплементация
Отказ от логики печати со стороны клавиатуры позволяет это накостылять. Какой-нибудь софт говорит с нашей клавиатурой, а потом конвертирует это в обычные ОСные клавиатурные сигналы.

= Протокол [[u/steve key|Steve Key]]
**Steve Key:** я пока не готов полностью сформулировать идею нового протокола, поэтому вот так, заметками попытаюсь довести свои идеи.
1. Компьютер ждёт от клавиатуры юникод-символы, которые ему нужно вывести в текстовое поле, параллельно транслируются скан-коды «символьных» (алфавитно-цифро-препинаковых) клавиш (каждый в своей клавиатуре может легко сделать, чтобы раскладка была ЙЦУКЕН, а скан-коды транслировались от QWERTY) и коды нажатых «служебных» клавиш: моды и остальные «несимвольные»;
**bouncepaw:** Вот это очень интересная идея.
2. Раскладки (физические) и соответствие, скажем, заглавных и строчных букв (слой Shift) задаются **в клавиатуре**, всю логику продумывает автор клавиатуры;
3. В комплекте с драйвером идёт программа, позволяющая в графическом интерфейсе посмотреть и изменить раскладки и прочие настройки клавиатуры, в комплекте программы имеются различные раскладки, включая стандартные (причём, в удобном для чтения открытом виде), также с сайта можно скачать новые раскладки-настройки и прочее).
**bouncepaw:** 2 и 3 как у меня, норм.

= Протокол [[u/daninspace|Дана]]
Клавиатура посылает символы [[https://ru.wikipedia.org/wiki/Юникод|Юникода]]. Для функциональных клавиш типа Enter, Shift, Tab, Esc, Ctrl и т.д. зарезервированы отдельные символы.
**bouncepaw:** вот тут подробнее. Какой именно уникод? Какая кодировка? Советую utf-8.
**Dan:** Актуальная версия стандарта. Кодировка либо какая-нибудь фиксированной длины для ускорения обработки, либо UTF-8.
ОС может не иметь встроенных раскладок вообще — она читает готовые символы (ну разве что для совместимости со старыми). Для частых вещей типа  цикличной смены раскладки, жесткой смены раскладки, медиаклавиш (изменение громкости, пауза и т.п.) и вообще для всего, что хочется, можно зарезервировать свой символ в Юникоде - места хватит на всё. Клавиатуру также легко программировать - по сути просто настраивать отправляемый текст. Хочешь запятую с пробелом - просто пишешь что то вроде:
```
KEY_1 = ", ";
```
Также очень легко получается программировать слои и т.п. Для языков вроде корейского легко делать автозамену букв на слоги  прямо в клавиатуре. Для поддержки протокола не требуется усложнение или удорожание устройства клавиатуры - обычные люди не заметят разницы при переходе на новый протокол. Двусторонняя передача данных так же доступна - всё тот же Юникод.
**bouncepaw:** а где хранятся раскладки? Если в клаве, то усложнение и удорожание потребуется.
**Dan:** сейчас клавиатуры как то посылают коды клавиш. Обычным клавиатурам просто надо коды поменять. В случае нескольких языков, где то подойдут и старые клавиатурные контроллеры, где то нет. Однако они даже для личного использования стоят дёшево, а при производственных объёмах вообще копейки.
**bouncepaw:** да ни одна старая массовая клавиатура не потянет этот протокол, потому что он радикально отличается от HID: протокол двухсторонний, а контроллеры массовых клавиатур к такому наверняка не готовы. И насчёт того, что достаточно только коды поменять, спорно. Надо бы и мне, и тебе примеры сообщений на наших протоколах сделать, чтобы понятнее было :-)
**Dan:** поддерживать двухстороннюю связь не обязательно для старых клавиатур. Вообще, всё легаси пусть работает как легаси. Производители всегда могут навариться на новых технологиях засчёт рекламы => им выгодно внедрять новый протокол:) Примеры протоколов будут ... когда-нибудь.
> </details>